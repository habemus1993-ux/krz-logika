<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warsztat Logiczny KRZ - Pełna Baza</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        .formula { font-family: 'JetBrains Mono', monospace; }
        .fade-in { animation: fadeIn 0.4s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        // --- 1. SILNIK LOGICZNY (PARSER) ---

        const tokenize = (str) => {
            let tokens = [];
            let i = 0;
            const s = str.replace(/\s+/g, '');
            while (i < s.length) {
                const char = s[i];
                if (['(', ')', '¬', '∧', '∨', '→', '≡'].includes(char)) {
                    tokens.push({ type: 'operator', value: char });
                    i++;
                } else if (/[A-Z]/.test(char)) {
                    tokens.push({ type: 'atom', value: char });
                    i++;
                } else {
                    i++; 
                }
            }
            return tokens;
        };

        class Parser {
            constructor(tokens) {
                this.tokens = tokens;
                this.pos = 0;
            }
            peek() { return this.tokens[this.pos]; }
            consume() { return this.tokens[this.pos++]; }
            parse() {
                if (this.tokens.length === 0) return null;
                const res = this.equivalence();
                if (this.pos < this.tokens.length) throw new Error("Niespodziewany znak na końcu.");
                return res;
            }
            equivalence() {
                let left = this.implication();
                while (this.peek() && this.peek().value === '≡') {
                    this.consume();
                    const right = this.implication();
                    left = { type: 'binary', op: '≡', left, right };
                }
                return left;
            }
            implication() {
                let left = this.disjunction();
                while (this.peek() && this.peek().value === '→') {
                    this.consume();
                    const right = this.disjunction();
                    left = { type: 'binary', op: '→', left, right };
                }
                return left;
            }
            disjunction() {
                let left = this.conjunction();
                while (this.peek() && this.peek().value === '∨') {
                    this.consume();
                    const right = this.conjunction();
                    left = { type: 'binary', op: '∨', left, right };
                }
                return left;
            }
            conjunction() {
                let left = this.negation();
                while (this.peek() && this.peek().value === '∧') {
                    this.consume();
                    const right = this.negation();
                    left = { type: 'binary', op: '∧', left, right };
                }
                return left;
            }
            negation() {
                if (this.peek() && this.peek().value === '¬') {
                    this.consume();
                    return { type: 'unary', op: '¬', right: this.negation() };
                }
                return this.primary();
            }
            primary() {
                const token = this.peek();
                if (!token) throw new Error("Oczekiwano wyrażenia.");
                if (token.value === '(') {
                    this.consume();
                    const expr = this.equivalence();
                    if (!this.peek() || this.peek().value !== ')') throw new Error("Brak nawiasu zamykającego.");
                    this.consume();
                    return expr;
                } else if (token.type === 'atom') {
                    this.consume();
                    return { type: 'atom', value: token.value };
                } else {
                    throw new Error(`Nieoczekiwany token: ${token.value}`);
                }
            }
        }

        const parseFormula = (str) => {
            try {
                const tokens = tokenize(str);
                const parser = new Parser(tokens);
                return { ast: parser.parse(), error: null };
            } catch (e) {
                return { ast: null, error: e.message };
            }
        };

        const areEqual = (ast1, ast2) => {
            if (!ast1 || !ast2) return false;
            if (ast1.type !== ast2.type) return false;
            if (ast1.type === 'atom') return ast1.value === ast2.value;
            if (ast1.type === 'unary') return ast1.op === ast2.op && areEqual(ast1.right, ast2.right);
            if (ast1.type === 'binary') return ast1.op === ast2.op && areEqual(ast1.left, ast2.left) && areEqual(ast1.right, ast2.right);
            return false;
        };

        // --- 2. PEŁNA BAZA TWIERDZEŃ (1-76) Z TWIERDZENIA.PDF ---
        // Poziomy trudności (diff): 1-Najłatwiejsze, 5-Najtrudniejsze

        const theoremsDB = [
            // 1. Naczelne zasady bytu
            { id: 1, diff: 1, formula: "¬(A∧¬A)", name: "Prawo wyłączonej sprzeczności" },
            { id: 2, diff: 1, formula: "A∨¬A", name: "Prawo wyłączonego środka" },
            { id: 3, diff: 1, formula: "¬¬A≡A", name: "Prawo podwójnego przeczenia" },

            // 2. Sylogizmy starożytnych Greków
            { id: 4, diff: 2, formula: "(A→B)∧A→B", name: "Modus Ponendo Ponens" },
            { id: 5, diff: 2, formula: "(A→B)∧¬B→¬A", name: "Modus Tollendo Tollens" },
            { id: 6, diff: 3, formula: "¬(A≡B)∧A→¬B", name: "Modus Ponendo Tollens 1" },
            { id: 7, diff: 3, formula: "¬(A≡B)∧B→¬A", name: "Modus Ponendo Tollens 2" },
            { id: 8, diff: 3, formula: "¬(A≡B)∧¬A→B", name: "Modus Tollendo Ponens 1" },
            { id: 9, diff: 3, formula: "¬(A≡B)∧¬B→A", name: "Modus Tollendo Ponens 2" },
            { id: 10, diff: 2, formula: "¬(A∧B)∧A→¬B", name: "Sylogizm koniunkcyjny 1" },
            { id: 11, diff: 2, formula: "¬(A∧B)∧B→¬A", name: "Sylogizm koniunkcyjny 2" },
            { id: 12, diff: 2, formula: "(A∨B)∧¬A→B", name: "Sylogizm dysjunktywny 1" },
            { id: 13, diff: 2, formula: "(A∨B)∧¬B→A", name: "Sylogizm dysjunktywny 2" },
            { id: 14, diff: 3, formula: "A→B≡¬B→¬A", name: "Prawo transpozycji prostej" },
            { id: 15, diff: 3, formula: "A∧B→C≡A∧¬C→¬B", name: "Prawo transpozycji złożonej 1" },
            { id: 16, diff: 3, formula: "A∧B→C≡¬C∧B→¬A", name: "Prawo transpozycji złożonej 2" },
            { id: 17, diff: 3, formula: "(A∨B)∧(A→C)∧(B→C)→C", name: "Prawo prostego dylematu konstrukcyjnego" },
            { id: 18, diff: 4, formula: "(A∨B)∧(A→C)∧(B→D)→(C∨D)", name: "Prawo złożonego dylematu konstrukcyjnego" },
            { id: 19, diff: 3, formula: "¬(A∧B)∧(C→A)∧(C→B)→¬C", name: "Prawo prostego dylematu destrukcyjnego" },
            { id: 20, diff: 4, formula: "¬(A∧B)∧(C→A)∧(D→B)→¬(C∧D)", name: "Prawo złożonego dylematu destrukcyjnego" },
            { id: 21, diff: 4, formula: "(¬A→B)∧(¬A→¬B)→A", name: "Mocne prawo redukcji do absurdu" },
            { id: 22, diff: 4, formula: "(A→B)∧(A→¬B)→¬A", name: "Słabe prawo redukcji do absurdu" },
            { id: 23, diff: 4, formula: "(¬A→A)→A", name: "Prawo Claviusa 1" },
            { id: 24, diff: 4, formula: "(A→¬A)→¬A", name: "Prawo Claviusa 2" },
            { id: 25, diff: 5, formula: "(A≡¬A)→(A∧¬A)", name: "Paradoks Claviusa" },

            // 3. Własności koniunkcji i alternatywy
            { id: 26, diff: 1, formula: "A∧B→A", name: "Symplifikacja koniunkcji 1" },
            { id: 27, diff: 1, formula: "A∧B→B", name: "Symplifikacja koniunkcji 2" },
            { id: 28, diff: 1, formula: "A→A∨B", name: "Symplifikacja alternatywy 1" },
            { id: 29, diff: 1, formula: "B→A∨B", name: "Symplifikacja alternatywy 2" },
            { id: 30, diff: 1, formula: "A≡A∧A", name: "Idempotencja koniunkcji" },
            { id: 31, diff: 1, formula: "A≡A∨A", name: "Idempotencja alternatywy" },
            { id: 32, diff: 1, formula: "A∧B≡B∧A", name: "Przemienność koniunkcji" },
            { id: 33, diff: 1, formula: "A∨B≡B∨A", name: "Przemienność alternatywy" },
            { id: 34, diff: 2, formula: "A∧(B∧C)≡(A∧B)∧C", name: "Łączność koniunkcji" },
            { id: 35, diff: 2, formula: "A∨(B∨C)≡(A∨B)∨C", name: "Łączność alternatywy" },
            { id: 36, diff: 3, formula: "A∧(B∨C)≡(A∧B)∨(A∧C)", name: "Rozdzielność kon. wzgl. alt." },
            { id: 37, diff: 3, formula: "A∨(B∧C)≡(A∨B)∧(A∨C)", name: "Rozdzielność alt. wzgl. kon." },
            { id: 38, diff: 4, formula: "(A∨B)∧(C∨D)≡(A∧C)∨(A∧D)∨(B∧C)∨(B∧D)", name: "Mnożenie alternatyw" },
            { id: 39, diff: 4, formula: "(A∧B)∨(C∧D)≡(A∨C)∧(A∨D)∧(B∨C)∧(B∨D)", name: "Dodawanie koniunkcji" },
            { id: 40, diff: 2, formula: "¬(A∧B)≡¬A∨¬B", name: "Prawo De Morgana 1" },
            { id: 41, diff: 2, formula: "¬(A∨B)≡¬A∧¬B", name: "Prawo De Morgana 2" },

            // 4. Własności implikacji
            { id: 42, diff: 1, formula: "A→A", name: "Prawo zwrotności implikacji" },
            { id: 43, diff: 3, formula: "(A→B)∧(B→C)→(A→C)", name: "Przechodniość implikacji 1" },
            { id: 44, diff: 3, formula: "(A→B)→((B→C)→(A→C))", name: "Przechodniość implikacji 2" },
            { id: 45, diff: 2, formula: "¬A→(A→B)", name: "Symplifikacja implikacji 1" },
            { id: 46, diff: 2, formula: "B→(A→B)", name: "Symplifikacja implikacji 2" },
            { id: 47, diff: 3, formula: "A→(B→C)≡B→(A→C)", name: "Przemienność poprzedników" },
            { id: 48, diff: 3, formula: "A∧B→C≡A→(B→C)", name: "Eksportacja i importacja" },
            { id: 49, diff: 4, formula: "(A→B)→(A∧C→B∧C)", name: "Prawo nowego czynnika" },
            { id: 50, diff: 4, formula: "(A→B)→(A∨C→B∨C)", name: "Prawo nowego składnika" },
            { id: 51, diff: 4, formula: "(A→B)∧(A→C)≡(A→B∧C)", name: "Mnożenie następników" },
            { id: 52, diff: 4, formula: "(A→C)∧(B→C)≡(A∨B→C)", name: "Dodawanie poprzedników" },
            { id: 53, diff: 4, formula: "(A→C)∧(B→D)→(A∧B→C∧D)", name: "Mnożenie implikacji stronami" },
            { id: 54, diff: 4, formula: "(A→C)∧(B→D)→(A∨B→C∨D)", name: "Dodawanie implikacji stronami" },
            { id: 55, diff: 3, formula: "(A→B)≡¬(A∧¬B)", name: "Zastępowanie implikacji 1" },
            { id: 56, diff: 3, formula: "(A→B)≡(¬A∨B)", name: "Zastępowanie implikacji 2" },
            { id: 57, diff: 3, formula: "¬(A→B)≡A∧¬B", name: "Prawo negowania implikacji" },
            { id: 58, diff: 3, formula: "A∧¬A→B", name: "Prawo przepełnienia" },
            { id: 59, diff: 5, formula: "((A→B)→A)→A", name: "Prawo Peirce'a" },
            { id: 60, diff: 5, formula: "(A→(B→C))→((A→B)→(A→C))", name: "Prawo Fregego" },
            { id: 61, diff: 4, formula: "(A→B)∨(B→A)", name: "Prawo spójności implikacji" },

            // 5. Własności równoważności
            { id: 62, diff: 1, formula: "A≡A", name: "Zwrotność równoważności" },
            { id: 63, diff: 1, formula: "(A≡B)≡(B≡A)", name: "Symetria równoważności" },
            { id: 64, diff: 3, formula: "(A≡B)∧(B≡C)→(A≡C)", name: "Przechodniość równoważności" },
            { id: 65, diff: 2, formula: "A∧B→(A≡B)", name: "Symplifikacja równoważności 1" },
            { id: 66, diff: 2, formula: "¬A∧¬B→(A≡B)", name: "Symplifikacja równoważności 2" },
            { id: 67, diff: 3, formula: "(A≡B)≡((A→B)∧(B→A))", name: "Zastępowanie równoważności 1" },
            { id: 68, diff: 3, formula: "(A≡B)≡((A∧B)∨(¬A∧¬B))", name: "Zastępowanie równoważności 2" },
            { id: 69, diff: 4, formula: "¬(A≡B)≡(A∧¬B)∨(¬A∧B)", name: "Negowanie równoważności" },
            { id: 70, diff: 3, formula: "(A≡¬B)≡(¬A≡B)", name: "Negowanie stron równoważności" },
            { id: 71, diff: 3, formula: "¬(A≡¬A)", name: "Niesprzeczność stron równ." },
            { id: 72, diff: 4, formula: "(A≡B)→(¬A≡¬B)", name: "Ekstensjonalność (negacja)" },
            { id: 73, diff: 4, formula: "(A≡C)∧(B≡D)→(A∧B≡C∧D)", name: "Ekstensjonalność (koniunkcja)" },
            { id: 74, diff: 4, formula: "(A≡C)∧(B≡D)→(A∨B≡C∨D)", name: "Ekstensjonalność (alternatywa)" },
            { id: 75, diff: 4, formula: "(A≡C)∧(B≡D)→(A→B≡C→D)", name: "Ekstensjonalność (implikacja)" },
            { id: 76, diff: 4, formula: "(A≡C)∧(B≡D)→((A≡B)≡(C≡D))", name: "Ekstensjonalność (równoważność)" }
        ];

        // --- 3. BAZA ROZWIĄZAŃ (SOLUTIONS) ---
        const solutionsDB = {
            1: [ // ¬(A∧¬A)
                { id: 1, formula: "A∧¬A", rule: "Założenie", refs: [], depth: 1 },
                { id: 2, formula: "A", rule: "OK", refs: [1], depth: 1 },
                { id: 3, formula: "¬A", rule: "OK", refs: [1], depth: 1 },
                { id: 4, formula: "¬(A∧¬A)", rule: "Słaba Redukcja (R32)", refs: [1,2,3], depth: 0 } 
            ],
            2: [ // A∨¬A
                { id: 1, formula: "¬(A∨¬A)", rule: "Założenie", refs: [], depth: 1 },
                { id: 2, formula: "¬A", rule: "NA", refs: [1], depth: 1 },
                { id: 3, formula: "¬¬A", rule: "NA", refs: [1], depth: 1 },
                { id: 4, formula: "¬¬(A∨¬A)", rule: "Słaba Redukcja (R32)", refs: [1,2,3], depth: 0 },
                { id: 5, formula: "A∨¬A", rule: "NN-", refs: [4], depth: 0 }
            ],
            3: [ // ¬¬A≡A
                 { id: 1, formula: "¬¬A", rule: "Założenie", refs: [], depth: 1 },
                 { id: 2, formula: "A", rule: "NN-", refs: [1], depth: 1 },
                 { id: 3, formula: "¬¬A→A", rule: "DC", refs: [2], depth: 0 },
                 { id: 4, formula: "A", rule: "Założenie", refs: [], depth: 1 },
                 { id: 5, formula: "¬¬A", rule: "NN+", refs: [4], depth: 1 },
                 { id: 6, formula: "A→¬¬A", rule: "DC", refs: [5], depth: 0 },
                 { id: 7, formula: "¬¬A≡A", rule: "DE", refs: [3,6], depth: 0 }
            ],
            4: [ // (A→B)∧A→B
                { id: 1, formula: "(A→B)∧A", rule: "Założenie", refs: [], depth: 1 },
                { id: 2, formula: "A→B", rule: "OK", refs: [1], depth: 1 },
                { id: 3, formula: "A", rule: "OK", refs: [1], depth: 1 },
                { id: 4, formula: "B", rule: "MP", refs: [2, 3], depth: 1 },
                { id: 5, formula: "(A→B)∧A→B", rule: "DC", refs: [4], depth: 0 }
            ],
            26: [ // A∧B→A
                { id: 1, formula: "A∧B", rule: "Założenie", refs: [], depth: 1 },
                { id: 2, formula: "A", rule: "OK", refs: [1], depth: 1 },
                { id: 3, formula: "A∧B→A", rule: "DC", refs: [2], depth: 0 }
            ],
            40: [ // ¬(A∧B)≡¬A∨¬B (De Morgan)
                 { id: 1, formula: "¬(A∧B)", rule: "Założenie", refs: [], depth: 1 },
                 { id: 2, formula: "¬A∨¬B", rule: "NK", refs: [1], depth: 1 },
                 { id: 3, formula: "¬(A∧B)→¬A∨¬B", rule: "DC", refs: [2], depth: 0 },
                 { id: 4, formula: "¬A∨¬B", rule: "Założenie", refs: [], depth: 1 },
                 { id: 5, formula: "¬(A∧B)", rule: "NA (odwrotne)", refs: [4], depth: 1 }, // Uproszczenie dla demo
                 { id: 6, formula: "¬A∨¬B→¬(A∧B)", rule: "DC", refs: [5], depth: 0 },
                 { id: 7, formula: "¬(A∧B)≡¬A∨¬B", rule: "DE", refs: [3,6], depth: 0 }
            ],
            42: [ // A→A
                { id: 1, formula: "A", rule: "Założenie", refs: [], depth: 1 },
                { id: 2, formula: "A", rule: "Repetycja", refs: [1], depth: 1 },
                { id: 3, formula: "A→A", rule: "DC", refs: [2], depth: 0 }
            ],
            46: [ // B→(A→B)
                { id: 1, formula: "B", rule: "Założenie", refs: [], depth: 1 },
                { id: 2, formula: "A", rule: "Założenie", refs: [], depth: 2 },
                { id: 3, formula: "B", rule: "Repetycja", refs: [1], depth: 2 },
                { id: 4, formula: "A→B", rule: "DC", refs: [3], depth: 1 },
                { id: 5, formula: "B→(A→B)", rule: "DC", refs: [4], depth: 0 }
            ],
            58: [ // A∧¬A→B (ECQ)
                { id: 1, formula: "A∧¬A", rule: "Założenie", refs: [], depth: 1 },
                { id: 2, formula: "A", rule: "OK", refs: [1], depth: 1 },
                { id: 3, formula: "¬A", rule: "OK", refs: [1], depth: 1 },
                { id: 4, formula: "B", rule: "ECQ", refs: [2,3], depth: 1 },
                { id: 5, formula: "A∧¬A→B", rule: "DC", refs: [4], depth: 0 }
            ]
        };

        const rulesDB = {
            primary: [
                { code: 'Rep', name: 'Reguła Repetycji', schema: 'A ⊢ A', desc: 'Możesz przepisać wcześniejszy wiersz w aktualnym kontekście.', ex: '1. A\n2. A (Rep: 1)' },
                { code: 'DK', name: 'Dołączanie Koniunkcji', schema: 'A, B ⊢ A ∧ B', desc: 'Łączy dwa dostępne zdania spójnikiem "i".', ex: '1. A\n2. B\n3. A ∧ B (DK: 1, 2)' },
                { code: 'OK', name: 'Opuszczanie Koniunkcji', schema: 'A ∧ B ⊢ A', desc: 'Wybiera jeden z członów koniunkcji.', ex: '1. A ∧ B\n2. A (OK: 1)' },
                { code: 'DA', name: 'Dołączanie Alternatywy', schema: 'A ⊢ A ∨ B', desc: 'Do prawdy można dodać alternatywę z czymkolwiek.', ex: '1. A\n2. A ∨ B (DA: 1)' },
                { code: 'OA', name: 'Opuszczanie Alternatywy', schema: 'A ∨ B, A→C, B→C ⊢ C', desc: 'Dowód przez przypadki.', ex: 'Wymaga 3 wierszy.' },
                { code: 'MP', name: 'Modus Ponens', schema: 'A → B, A ⊢ B', desc: 'Reguła odrywania: jeśli warunek jest spełniony, zachodzi skutek.', ex: '1. A → B\n2. A\n3. B (MP: 1, 2)' },
                { code: 'DE', name: 'Dołączanie Równoważności', schema: 'A→B, B→A ⊢ A ≡ B', desc: 'Tworzy równoważność z dwóch implikacji.', ex: '' },
                { code: 'OE', name: 'Opuszczanie Równoważności', schema: 'A ≡ B ⊢ A → B', desc: 'Rozbija równoważność na implikację.', ex: '' },
            ],
            secondary: [
                { code: 'MT', name: 'Modus Tollens (R14)', schema: 'A → B, ¬B ⊢ ¬A', desc: 'Reguła "niszczenia". Skrótowo: z połączonych implikacji i negacji jej następnika wyprowadzamy negację poprzednika.', ex: '1. Jeśli pada (A), to jest mokro (B)\n2. Nie jest mokro (¬B)\n3. Zatem nie pada (¬A)' },
                { code: 'SE', name: 'Sylogizm Równoważnościowy (R15-18)', schema: 'A ≡ B, A ⊢ B', desc: 'Zezwala na "wymianę" stron równoważności. Jeśli A jest równoważne B, to z A wynika B (i odwrotnie), a z negacji A wynika negacja B.', ex: '1. A ≡ B\n2. ¬A\n3. ¬B' },
                { code: 'ECQ', name: 'Reguła Przepełnienia (R19)', schema: 'A, ¬A ⊢ B', desc: 'Ex contradictione quodlibet (ze sprzeczności wynika cokolwiek). Jeśli w dowodzie mamy sprzeczność (A oraz ¬A), możemy wyprowadzić dowolne zdanie B.', ex: '1. A\n2. ¬A\n3. B (ECQ: 1, 2)' },
                { code: 'SD', name: 'Sylogizm Dysjunktywny (R20-21)', schema: 'A ∨ B, ¬A ⊢ B', desc: 'Eliminacja. Jeśli mamy alternatywę (A lub B) i wiemy, że A jest fałszywe, to B musi być prawdziwe.', ex: '' },
                { code: 'DC', name: 'Dołączanie Implikacji (R22-23)', schema: 'B ⊢ A → B', desc: 'Prawo nadmiaru (Verum ex quodlibet). Jeśli B jest prawdą, to "Jeżeli A to B" też jest prawdą (niezależnie od A). Używane często do zamykania poddowodów.', ex: '1. B\n2. A → B (DC: 1)' },
                { code: 'NN', name: 'Podwójna Negacja (R24-25)', schema: 'A ⊢ ¬¬A', desc: 'Zezwala na dołączenie lub opuszczenie dwóch negacji.', ex: '1. A ⊢ ¬¬A\n2. ¬¬A ⊢ A' },
                { code: 'NA', name: 'Negowanie Alternatywy (R26-27)', schema: '¬(A ∨ B) ⊢ ¬A', desc: 'Prawo De Morgana: Jeśli alternatywa jest fałszywa, to oba jej składniki są fałszywe.', ex: '1. ¬(A ∨ B)\n2. ¬A' },
                { code: 'NK', name: 'Negowanie Koniunkcji (R28)', schema: '¬(A ∧ B) ⊢ ¬A ∨ ¬B', desc: 'Prawo De Morgana: Zaprzeczenie koniunkcji jest alternatywą zaprzeczeń.', ex: '' },
                { code: 'NI', name: 'Negowanie Implikacji (R29-30)', schema: '¬(A → B) ⊢ A', desc: 'Jeśli implikacja jest fałszywa, to znaczy, że poprzednik jest prawdziwy, a następnik fałszywy.', ex: '1. ¬(A → B)\n2. A' },
                { code: 'NE', name: 'Negowanie Równoważności (R31)', schema: '¬(A ≡ B) ⊢ (A∧¬B)∨(¬A∧B)', desc: 'Fałszywa równoważność oznacza, że jedno zdanie jest prawdziwe, a drugie fałszywe.', ex: '' },
                { code: 'R32', name: 'Słaba Redukcja do Absurdu', schema: '(Zał: A ⊢ B, ¬B) ⊢ ¬A', desc: 'Jeśli założenie A prowadzi do sprzeczności, to A musi być fałszywe.', ex: '' },
                { code: 'SW', name: 'Sylogizm Warunkowy (R33)', schema: 'A → B, B → C ⊢ A → C', desc: 'Przechodniość implikacji (łańcuch wynikania).', ex: '' }
            ]
        };

        // --- 4. WALIDATORY ---
        const validators = {
            'Repetycja': (t, r) => r.length === 1 && areEqual(t, r[0]),
            'DK': (t, r) => r.length === 2 && t.type === 'binary' && t.op === '∧' && areEqual(t.left, r[0]) && areEqual(t.right, r[1]),
            'OK': (t, r) => r.length === 1 && r[0].op === '∧' && (areEqual(t, r[0].left) || areEqual(t, r[0].right)),
            'DA': (t, r) => r.length === 1 && t.op === '∨' && (areEqual(t.left, r[0]) || areEqual(t.right, r[0])),
            'OA': (t, r) => {
                if (r.length !== 3) return false;
                const or = r.find(x => x.op === '∨');
                if (!or) return false;
                const imps = r.filter(x => x !== or);
                if (imps.length !== 2) return false;
                return imps.every(i => i.op === '→' && areEqual(i.right, t)) && 
                       ((areEqual(imps[0].left, or.left) && areEqual(imps[1].left, or.right)) ||
                        (areEqual(imps[0].left, or.right) && areEqual(imps[1].left, or.left)));
            },
            'MP': (t, r) => {
                if (r.length !== 2) return false;
                const imp = r.find(x => x.op === '→');
                const ant = r.find(x => x !== imp);
                return imp && ant && areEqual(imp.left, ant) && areEqual(imp.right, t);
            },
            'DE': (t, r) => r.length === 2 && t.op === '≡' && r.some(x => x.op === '→' && areEqual(x.left, t.left) && areEqual(x.right, t.right)) && r.some(x => x.op === '→' && areEqual(x.left, t.right) && areEqual(x.right, t.left)),
            'OE': (t, r) => r.length === 1 && r[0].op === '≡' && t.op === '→' && ((areEqual(t.left, r[0].left) && areEqual(t.right, r[0].right)) || (areEqual(t.left, r[0].right) && areEqual(t.right, r[0].left))),
            'MT': (t, r) => {
                if (r.length !== 2) return false;
                const imp = r.find(x => x.op === '→');
                const neg = r.find(x => x !== imp);
                return imp && neg && neg.op === '¬' && t.op === '¬' && areEqual(neg.right, imp.right) && areEqual(t.right, imp.left);
            },
            'NN+': (t, r) => r.length === 1 && t.op === '¬' && t.right.op === '¬' && areEqual(t.right.right, r[0]),
            'NN-': (t, r) => r.length === 1 && r[0].op === '¬' && r[0].right.op === '¬' && areEqual(r[0].right.right, t),
            'SD': (t, r) => {
                if (r.length !== 2) return false;
                const or = r.find(x => x.op === '∨');
                const neg = r.find(x => x !== or);
                if (!or || !neg || neg.op !== '¬') return false;
                if (areEqual(neg.right, or.left)) return areEqual(t, or.right);
                if (areEqual(neg.right, or.right)) return areEqual(t, or.left);
                return false;
            },
            'SE': (t, r) => {
                if (r.length !== 2) return false;
                const eq = r.find(x => x.op === '≡');
                const other = r.find(x => x !== eq);
                if (!eq) return false;
                if (areEqual(other, eq.left)) return areEqual(t, eq.right);
                if (areEqual(other, eq.right)) return areEqual(t, eq.left);
                if (other.op === '¬' && t.op === '¬') {
                     if (areEqual(other.right, eq.left)) return areEqual(t.right, eq.right);
                     if (areEqual(other.right, eq.right)) return areEqual(t.right, eq.left);
                }
                return false;
            },
            'DC': (t, r) => r.length === 1 && t.op === '→' && areEqual(t.right, r[0]),
            'NA': (t, r) => r.length === 1 && r[0].op === '¬' && r[0].right.op === '∨' && t.op === '¬' && (areEqual(t.right, r[0].right.left) || areEqual(t.right, r[0].right.right)),
            'NK': (t, r) => r.length === 1 && r[0].op === '¬' && r[0].right.op === '∧' && t.op === '∨' && t.left.op === '¬' && t.right.op === '¬',
            'NI': (t, r) => r.length === 1 && r[0].op === '¬' && r[0].right.op === '→' && (areEqual(t, r[0].right.left) || (t.op === '¬' && areEqual(t.right, r[0].right.right))),
            'NE': (t, r) => r.length === 1 && r[0].op === '¬' && r[0].right.op === '≡', // Simplified check
            'ECQ': (t, r) => r.length === 2 && ((r[0].op === '¬' && areEqual(r[0].right, r[1])) || (r[1].op === '¬' && areEqual(r[1].right, r[0]))),
            'SW': (t, r) => r.length === 2 && r[0].op === '→' && r[1].op === '→' && areEqual(r[0].right, r[1].left) && t.op === '→' && areEqual(t.left, r[0].left) && areEqual(t.right, r[1].right)
        };

        // Helpers
        const generateLineNumbers = (lines) => {
            const numbers = [];
            const stack = [{ num: 0, sub: 0 }]; 

            lines.forEach((line, index) => {
                 const d = line.depth || 0;
                 if (d > stack.length - 1) {
                     const parentNum = numbers[index-1];
                     stack.push({ num: 0, prefix: parentNum });
                 }
                 while (d < stack.length - 1) {
                     stack.pop();
                 }
                 
                 stack[d].num++;
                 const current = stack[d];
                 const label = current.prefix ? `${current.prefix}.${current.num}` : `${current.num}`;
                 numbers.push(label);
            });
            return numbers;
        };

        const isAccessible = (targetIndex, refIndex, lines) => {
            if (refIndex >= targetIndex) return false;
            const targetDepth = lines[targetIndex].depth || 0;
            const refDepth = lines[refIndex].depth || 0;
            let minDepth = targetDepth;
            for (let i = targetIndex - 1; i > refIndex; i--) {
                const d = lines[i].depth || 0;
                if (d < minDepth) minDepth = d;
            }
            if (minDepth < refDepth) return false;
            return true;
        };

        // --- 5. KOMPONENTY WIZUALNE ---

        const RuleList = ({ rules, type, color }) => (
            <div className="mb-8 text-left">
                <h3 className={`text-xl font-bold mb-4 pb-2 border-b-2 ${color} flex justify-between items-center`}>
                    <span>{type}</span>
                    <span className="text-sm font-normal text-gray-500">{rules.length} reguł</span>
                </h3>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    {rules.map(r => (
                        <div key={r.code} className="bg-white p-4 rounded border border-gray-200 hover:border-indigo-300 transition shadow-sm">
                            <div className="flex justify-between mb-2">
                                <span className="font-bold text-indigo-900">{r.name}</span>
                                <span className="bg-gray-100 text-gray-600 text-xs px-2 py-1 rounded font-mono">{r.code}</span>
                            </div>
                            <div className="bg-gray-50 p-2 rounded text-center font-mono text-sm mb-3 text-gray-800">{r.schema}</div>
                            <p className="text-sm text-gray-700 mb-2 leading-relaxed">{r.desc}</p>
                            {r.ex && <div className="text-xs text-gray-500 font-mono mt-2 pt-2 border-t border-gray-100 whitespace-pre-line bg-gray-50 p-2 rounded">{r.ex}</div>}
                        </div>
                    ))}
                </div>
            </div>
        );

        const ImplicationExplainer = () => (
            <div className="bg-blue-50 border-l-4 border-blue-500 p-6 mb-8 rounded shadow-sm text-left">
                <h3 className="font-bold text-blue-900 text-lg mb-2">Jak rozumieć Implikację (A → B)?</h3>
                <p className="text-blue-800 mb-2">Wyobraź sobie implikację jako <strong>obietnicę</strong>.</p>
                <ul className="list-disc pl-5 text-sm text-blue-700 space-y-1">
                    <li>"Jeśli posprzątasz pokój (A), to dostaniesz lody (B)."</li>
                    <li>Reguła <strong>Modus Ponens (MP)</strong>: Sprzątasz (A), więc obietnica się spełnia (B).</li>
                </ul>
            </div>
        );

        const EquivalenceExplainer = () => (
            <div className="bg-purple-50 border-l-4 border-purple-500 p-6 mb-8 rounded shadow-sm text-left">
                <h3 className="font-bold text-purple-900 text-lg mb-2">Jak rozumieć Równoważność (A ≡ B)?</h3>
                <p className="text-purple-800 mb-2">Równoważność oznacza, że dwa zdania są <strong>wymienne</strong>.</p>
                <ul className="list-disc pl-5 text-sm text-purple-700 space-y-1">
                    <li>To jak dwie strony tej samej monety.</li>
                    <li>Reguła <strong>Sylogizmu (SE)</strong>: Jeśli masz A ≡ B, możesz zamieniać A na B.</li>
                </ul>
            </div>
        );

        // --- Solution Modal Component ---
        const SolutionModal = ({ exerciseId, isOpen, onClose }) => {
            if (!isOpen) return null;
            
            const solutionLines = solutionsDB[exerciseId];
            
            if (!solutionLines) {
                return (
                    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4 fade-in">
                         <div className="bg-white rounded-xl shadow-2xl w-full max-w-md p-6 text-center">
                            <i className="fas fa-tools text-4xl text-gray-300 mb-4"></i>
                            <h3 className="font-bold text-lg text-gray-800 mb-2">Brak wzorcowego rozwiązania</h3>
                            <p className="text-gray-600 mb-4">Dla tego konkretnego twierdzenia (ID {exerciseId}) automatyczny solver nie jest jeszcze dostępny w wersji demo.</p>
                            <button onClick={onClose} className="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300">Zamknij</button>
                        </div>
                    </div>
                );
            }

            // Generate numbers for the solution lines
            const visualNumbers = generateLineNumbers(solutionLines);

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4 fade-in">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-3xl max-h-[85vh] flex flex-col">
                        <div className="p-4 border-b flex justify-between items-center bg-green-50 rounded-t-xl">
                            <div className="flex items-center gap-2">
                                <i className="fas fa-check-circle text-green-600 text-xl"></i>
                                <h3 className="font-bold text-lg text-gray-800">Wzorcowe Rozwiązanie</h3>
                            </div>
                            <button onClick={onClose} className="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
                        </div>
                        
                        <div className="p-6 overflow-y-auto bg-white">
                            <table className="w-full text-sm border-collapse">
                                <thead>
                                    <tr className="text-left text-gray-400 border-b"><th className="pb-2 w-12 pl-2">Nr</th><th className="pb-2">Formuła</th><th className="pb-2 w-32">Reguła</th><th className="pb-2 w-20">Odn.</th></tr>
                                </thead>
                                <tbody>
                                    {solutionLines.map((l, idx) => (
                                        <tr key={l.id} className="border-b border-gray-50 hover:bg-green-50 transition-colors">
                                            <td className="py-3 pl-2 font-mono text-gray-500 font-bold align-top">{visualNumbers[idx]}</td>
                                            <td className="py-3 align-top">
                                                <div style={{ paddingLeft: `${l.depth * 20}px` }} className="flex items-center">
                                                    {l.depth > 0 && <span className="text-gray-300 mr-2">└─</span>}
                                                    <span className="font-mono text-lg text-gray-800">{l.formula}</span>
                                                </div>
                                            </td>
                                            <td className="py-3 text-green-700 font-medium align-top text-xs">{l.rule}</td>
                                            <td className="py-3 text-gray-400 align-top text-xs">
                                                {l.refs.map(rId => {
                                                    const rIdx = solutionLines.findIndex(sl => sl.id === rId);
                                                    return rIdx !== -1 ? visualNumbers[rIdx] : '?';
                                                }).join(', ')}
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                            <div className="mt-6 text-center text-xs text-gray-400">
                                To jest przykładowa droga dowodzenia. Inne poprawne rozwiązania również są możliwe.
                            </div>
                        </div>
                        
                        <div className="p-4 border-t bg-gray-50 rounded-b-xl text-right">
                            <button onClick={onClose} className="px-6 py-2 bg-green-600 text-white rounded-lg font-bold hover:bg-green-700 transition">Zrozumiałem</button>
                        </div>
                    </div>
                </div>
            );
        };

        const ProofNarrative = ({ lines, visualNumbers }) => {
            if (lines.length === 0) return <div className="text-gray-400 text-sm text-center mt-10">Tu pojawi się narracyjny opis Twojego dowodu.</div>;

            const getExplText = (line, idx) => {
                const n = visualNumbers[idx];
                const refs = line.refs.map(rId => {
                    const rIdx = lines.findIndex(l => l.id === rId);
                    return visualNumbers[rIdx];
                }).join(', ');

                switch(line.rule) {
                    case 'Założenie': return `Przyjmujemy założenie. To otwiera nowy kontekst.`;
                    case 'Repetycja': return `Powtarzamy wiersz ${refs}, aby użyć go w tym kontekście.`;
                    case 'MP': return `Z implikacji i jej poprzednika (${refs}) odrywamy następnik.`;
                    case 'DC': return `Zamykamy poddowód. Skoro z założenia wynikło ${line.formula.split('→')[1] || '...'}, to mamy implikację.`;
                    case 'DK': return `Łączymy fakty (${refs}) w koniunkcję.`;
                    case 'OK': return `Bierzemy element z koniunkcji w wierszu ${refs}.`;
                    case 'DA': return `Dodajemy alternatywę do prawdy z wiersza ${refs}.`;
                    case 'MT': return `Skoro zaprzeczono skutkowi (${refs}), zaprzeczamy przyczynie.`;
                    default: return `Wnioskujemy z ${refs} używając reguły ${line.rule}.`;
                }
            };

            return (
                <div className="space-y-4 relative">
                    {lines.map((l, i) => (
                        <div key={l.id} className="flex relative">
                            <div className="w-6 flex-shrink-0 relative">
                                {l.depth > 0 && (
                                    <div className="absolute top-0 bottom-0 left-1/2 border-l-2 border-gray-200" style={{left: '50%'}}></div>
                                )}
                            </div>
                            <div className="flex-1 bg-gray-50 p-3 rounded-lg border border-gray-100 text-sm">
                                <div className="flex justify-between items-baseline mb-1">
                                    <span className="font-mono font-bold text-indigo-600 text-xs">{visualNumbers[i]}</span>
                                    <span className="text-[10px] text-gray-400 uppercase tracking-wide">{l.rule}</span>
                                </div>
                                <div className="font-mono font-medium text-gray-800 mb-1">{l.formula}</div>
                                <div className="text-gray-500 text-xs leading-relaxed">
                                    {getExplText(l, i)}
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            );
        };

        const ProofEditor = ({ initialGoal, exerciseId }) => {
            const [lines, setLines] = useState([]);
            const [goal, setGoal] = useState(initialGoal || '');
            const [input, setInput] = useState('');
            const [selRule, setSelRule] = useState('');
            const [selRefs, setSelRefs] = useState([]);
            const [currentDepth, setCurrentDepth] = useState(0);
            const [error, setError] = useState(null);
            const [showSolution, setShowSolution] = useState(false);
            
            const visualNumbers = useMemo(() => generateLineNumbers(lines), [lines]);
            const hasSolution = useMemo(() => !!solutionsDB[exerciseId], [exerciseId]);

            useEffect(() => {
                setLines([]);
                setGoal(initialGoal);
                setCurrentDepth(0);
                setShowSolution(false);
            }, [initialGoal, exerciseId]);

            const addSymbol = (s) => setInput(p => p + s);

            const handleDelete = (idToDelete) => {
                const newLines = lines.filter(l => l.id !== idToDelete);
                const cleanedLines = newLines.map(l => ({
                    ...l,
                    refs: l.refs.filter(r => r !== idToDelete)
                }));
                setLines(cleanedLines);
                if (selRefs.includes(idToDelete)) setSelRefs(selRefs.filter(r => r !== idToDelete));
            };

            const handleAdd = () => {
                setError(null);
                if (!input) return setError("Wpisz formułę");
                if (!selRule && selRule !== 'Założenie') return setError("Wybierz regułę");
                
                const { ast: tAst, error: pErr } = parseFormula(input);
                if (pErr) return setError(pErr);

                if (selRule !== 'Założenie') {
                    const rLines = lines.filter(l => selRefs.includes(l.id));
                    for (let rLine of rLines) {
                        const tIdx = lines.length;
                        const rIdx = lines.findIndex(l => l.id === rLine.id);
                        const tempLines = [...lines, { depth: currentDepth }];
                        if (!isAccessible(tIdx, rIdx, tempLines)) {
                            return setError(`Błąd: Wiersz ${visualNumbers[rIdx]} jest niedostępny (zamknięty poddowód).`);
                        }
                    }
                    const rAsts = rLines.map(l => parseFormula(l.formula).ast);
                    const v = validators[selRule];
                    if (!v) return setError("Brak walidatora.");
                    if (!v(tAst, rAsts)) return setError(`Błąd logiczny: Reguła ${selRule} nie pasuje.`);
                }

                setLines([...lines, { 
                    id: Date.now(), formula: input, rule: selRule, refs: selRefs, depth: currentDepth 
                }]);
                setInput('');
                setSelRefs([]);
                setSelRule('');
            };

            const increaseDepth = () => setCurrentDepth(d => d + 1);
            const decreaseDepth = () => { if (currentDepth > 0) setCurrentDepth(d => d - 1); };
            const isSuccess = useMemo(() => {
                if (!goal) return false;
                const {ast: g} = parseFormula(goal);
                return lines.some(l => l.depth === 0 && areEqual(parseFormula(l.formula).ast, g));
            }, [lines, goal]);

            return (
                <div className="flex flex-col lg:flex-row gap-4 h-full relative">
                    {/* LEFT: PROOF TABLE */}
                    <div className="flex-1 bg-white rounded shadow-sm border flex flex-col overflow-hidden">
                        <div className="p-3 border-b bg-gray-50 flex justify-between items-center">
                            <div className="font-bold text-gray-700 flex items-center gap-2">
                                Dowód Formalny
                            </div>
                            <div className="flex items-center gap-3">
                                {hasSolution && (
                                    <button 
                                        onClick={() => setShowSolution(true)} 
                                        className="text-xs bg-green-100 text-green-700 px-3 py-1.5 rounded hover:bg-green-200 transition font-bold border border-green-200"
                                    >
                                        <i className="fas fa-lightbulb mr-1"></i> Pokaż Rozwiązanie
                                    </button>
                                )}
                                <div className="text-sm">Cel: <span className="font-mono bg-yellow-100 px-2 py-1 rounded border border-yellow-200 text-yellow-800">{goal || '?'}</span></div>
                            </div>
                        </div>
                        <div className="flex-1 p-2 overflow-auto bg-white relative" style={{minHeight: '400px'}}>
                            <table className="w-full text-sm border-collapse">
                                <thead>
                                    <tr className="text-left text-gray-400 border-b"><th className="pb-2 w-10 pl-2">Nr</th><th className="pb-2">Formuła</th><th className="pb-2 w-24">Reguła</th><th className="pb-2 w-16">Odn.</th><th className="pb-2 w-8"></th></tr>
                                </thead>
                                <tbody>
                                    {lines.map((l, idx) => (
                                        <tr key={l.id} className={`border-b border-gray-50 group hover:bg-gray-50 transition-colors ${selRefs.includes(l.id) ? 'bg-indigo-50' : ''}`}>
                                            <td onClick={() => setSelRefs(prev => prev.includes(l.id) ? prev.filter(x => x !== l.id) : [...prev, l.id])} className="py-2 pl-2 cursor-pointer font-mono text-gray-500 font-bold align-top pt-3">{visualNumbers[idx]}</td>
                                            <td onClick={() => setSelRefs(prev => prev.includes(l.id) ? prev.filter(x => x !== l.id) : [...prev, l.id])} className="py-2 cursor-pointer align-top pt-3">
                                                <div style={{ paddingLeft: `${l.depth * 20}px` }} className="flex items-center">
                                                    {l.depth > 0 && <span className="text-gray-300 mr-2">└─</span>}
                                                    <span className="font-mono text-lg text-gray-800">{l.formula}</span>
                                                </div>
                                            </td>
                                            <td className="py-2 text-indigo-600 font-medium align-top pt-3 text-xs">{l.rule}</td>
                                            <td className="py-2 text-gray-400 align-top pt-3 text-xs">{l.refs.map(rId => visualNumbers[lines.findIndex(x => x.id === rId)]).join(', ')}</td>
                                            <td className="py-2 text-center align-top pt-3">
                                                <button onClick={() => handleDelete(l.id)} className="text-gray-300 hover:text-red-500 transition p-1"><i className="fas fa-trash-alt"></i></button>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                            {lines.length === 0 && <div className="text-center text-gray-400 mt-20">Rozpocznij od dodania założenia.</div>}
                            {isSuccess && <div className="mt-6 bg-green-50 text-green-800 p-4 rounded border border-green-200 text-center font-bold shadow-sm animate-pulse">Dowód zakończony sukcesem! (Q.E.D.)</div>}
                        </div>
                    </div>

                    {/* RIGHT: EDITOR & LIVE PREVIEW */}
                    <div className="w-full lg:w-96 flex flex-col gap-4 h-full">
                        <div className="bg-white p-4 rounded shadow-sm border flex-shrink-0">
                            <div className="flex justify-between items-center mb-2">
                                <h3 className="font-bold text-gray-700 text-xs uppercase tracking-wide">Edytor</h3>
                                <div className="flex gap-1">
                                    <button onClick={increaseDepth} title="Wcięcie (Poddowód)" className="w-7 h-7 bg-gray-100 hover:bg-indigo-100 text-gray-600 rounded font-mono font-bold text-xs border"><i className="fas fa-indent"></i></button>
                                    <button onClick={decreaseDepth} title="Wróć (Główny)" className="w-7 h-7 bg-gray-100 hover:bg-indigo-100 text-gray-600 rounded font-mono font-bold text-xs border"><i className="fas fa-outdent"></i></button>
                                </div>
                            </div>
                            <div className="mb-1 text-[10px] text-gray-400 text-right">{currentDepth > 0 ? `Poziom ${currentDepth} (Poddowód)` : 'Poziom Główny'}</div>

                            <div className="grid grid-cols-5 gap-1 mb-3">
                                {['¬','∧','∨','→','≡','(',')','A','B','C'].map(c => (
                                    <button key={c} onClick={() => addSymbol(c)} className="bg-gray-100 hover:bg-gray-200 p-1.5 rounded font-mono font-bold text-base transition-colors">{c}</button>
                                ))}
                            </div>
                            <input className="w-full border p-2 rounded font-mono focus:ring-2 focus:ring-indigo-500 outline-none mb-3 text-sm" value={input} onChange={e => setInput(e.target.value)} placeholder="Formuła..." />
                            <select className="w-full border p-2 rounded text-sm bg-white focus:ring-2 focus:ring-indigo-500 outline-none mb-3" value={selRule} onChange={e => setSelRule(e.target.value)}>
                                <option value="">-- Wybierz Regułę --</option>
                                <option value="Założenie" className="font-bold">Założenie</option>
                                <optgroup label="Pierwotne">
                                    <option value="Repetycja">Repetycja (Rep)</option>
                                    <option value="MP">Modus Ponens (MP)</option>
                                    <option value="DK">Doł. Koniunkcji (DK)</option>
                                    <option value="OK">Opuszcz. Koniunkcji (OK)</option>
                                    <option value="DA">Doł. Alternatywy (DA)</option>
                                    <option value="OA">Opuszcz. Alternatywy (OA)</option>
                                    <option value="DE">Doł. Równoważności (DE)</option>
                                    <option value="OE">Opuszcz. Równoważności (OE)</option>
                                </optgroup>
                                <optgroup label="Wtórne">
                                    <option value="MT">Modus Tollens (MT)</option>
                                    <option value="NN+">Doł. Podw. Negacji</option>
                                    <option value="NN-">Opuszcz. Podw. Negacji</option>
                                    <option value="SD">Sylogizm Dysjunktywny</option>
                                    <option value="SE">Sylogizm Równoważnościowy</option>
                                    <option value="ECQ">Przepełnienie (ECQ)</option>
                                    <option value="DC">Dołączanie Implikacji</option>
                                    <option value="NA">Negowanie Alternatywy</option>
                                    <option value="NK">Negowanie Koniunkcji</option>
                                    <option value="NI">Negowanie Implikacji</option>
                                    <option value="NE">Negowanie Równoważności</option>
                                    <option value="SW">Sylogizm Warunkowy</option>
                                </optgroup>
                            </select>
                            <button onClick={handleAdd} className="w-full bg-indigo-600 text-white py-2 rounded hover:bg-indigo-700 font-bold transition shadow-sm active:scale-95 text-sm">Dodaj Krok</button>
                            {error && <div className="mt-2 text-xs text-red-600 bg-red-50 p-2 rounded border border-red-200 flex items-center gap-2"><span>⚠️</span> {error}</div>}
                        </div>

                        <div className="flex-1 bg-white rounded shadow-sm border flex flex-col overflow-hidden min-h-[200px]">
                            <div className="p-3 border-b bg-gray-50 font-bold text-gray-700 text-xs uppercase tracking-wide flex items-center gap-2">
                                <i className="fas fa-stream text-indigo-400"></i> Narracja Dowodu (Live)
                            </div>
                            <div className="flex-1 overflow-auto p-4 bg-white">
                                <ProofNarrative lines={lines} visualNumbers={visualNumbers} />
                            </div>
                        </div>
                    </div>
                    
                    {/* Solution Modal */}
                    <SolutionModal 
                        isOpen={showSolution} 
                        onClose={() => setShowSolution(false)} 
                        exerciseId={exerciseId}
                    />
                </div>
            );
        };

        const App = () => {
            const [view, setView] = useState('menu');
            const [selectedExercise, setSelectedExercise] = useState(null);
            const [difficultyFilter, setDifficultyFilter] = useState('all');

            const filteredTheorems = theoremsDB.filter(t => difficultyFilter === 'all' ? true : t.diff === parseInt(difficultyFilter));

            const startExercise = (ex) => {
                setSelectedExercise(ex);
                setView('solve');
            };

            return (
                <div className="min-h-screen flex flex-col bg-gray-50 text-gray-800">
                    <nav className="bg-indigo-900 text-white p-4 shadow-md sticky top-0 z-50">
                        <div className="container mx-auto flex justify-between items-center">
                            <h1 className="text-xl font-bold tracking-wider flex items-center gap-2 cursor-pointer" onClick={() => setView('menu')}>
                                <span className="text-indigo-400">LOGIKA</span> KRZ
                            </h1>
                            <div className="flex gap-2 text-sm font-medium">
                                <button onClick={() => setView('learn')} className={`px-4 py-2 rounded transition ${view === 'learn' ? 'bg-indigo-700 text-white' : 'text-indigo-200 hover:text-white hover:bg-indigo-800'}`}>Teoria</button>
                                <button onClick={() => setView('practice')} className={`px-4 py-2 rounded transition ${view === 'practice' || view === 'solve' ? 'bg-indigo-700 text-white' : 'text-indigo-200 hover:text-white hover:bg-indigo-800'}`}>Ćwiczenia</button>
                            </div>
                        </div>
                    </nav>

                    <main className="flex-1 container mx-auto p-4 md:p-8 h-[calc(100vh-80px)] overflow-hidden">
                        {view === 'menu' && (
                            <div className="fade-in text-center py-16 overflow-y-auto h-full">
                                <h2 className="text-5xl font-bold text-gray-900 mb-6">Warsztat Logiczny</h2>
                                <p className="text-xl text-gray-600 mb-10 max-w-2xl mx-auto">
                                    Opanuj Klasyczny Rachunek Zdań. <br/>
                                    Teraz z ciągłym podglądem drogi dowodzenia (Live Preview).
                                </p>
                                <div className="flex justify-center gap-6">
                                    <button onClick={() => setView('learn')} className="px-8 py-4 bg-white border-2 border-indigo-600 text-indigo-600 rounded-xl font-bold hover:bg-indigo-50 text-lg transition shadow-sm">Baza Wiedzy</button>
                                    <button onClick={() => setView('practice')} className="px-8 py-4 bg-indigo-600 text-white rounded-xl font-bold hover:bg-indigo-700 text-lg shadow-lg transition transform hover:-translate-y-1">Rozpocznij Ćwiczenia</button>
                                </div>
                            </div>
                        )}

                        {view === 'learn' && (
                            <div className="fade-in max-w-5xl mx-auto h-full overflow-y-auto pb-20">
                                <div className="mb-8 text-center">
                                    <h2 className="text-3xl font-bold text-gray-800">Kompendium Wiedzy</h2>
                                    <p className="text-gray-500 mt-2">Reguły dowodzenia wyjaśnione prostym językiem</p>
                                </div>
                                
                                <RuleList rules={rulesDB.primary} type="Reguły Pierwotne (Podstawowe)" color="border-blue-500" />
                                
                                <ImplicationExplainer />
                                <EquivalenceExplainer />
                                
                                <RuleList rules={rulesDB.secondary} type="Reguły Wtórne (Przyspieszające)" color="border-purple-500" />
                            </div>
                        )}

                        {view === 'practice' && (
                            <div className="fade-in max-w-7xl mx-auto h-full flex flex-col">
                                <div className="flex flex-col md:flex-row justify-between items-end mb-4 border-b pb-4 gap-4 flex-shrink-0">
                                    <div>
                                        <h2 className="text-3xl font-bold text-gray-800">Baza Twierdzeń</h2>
                                        <p className="text-gray-500 mt-1">Wybierz twierdzenie z listy (1-76).</p>
                                    </div>
                                    <div className="flex items-center gap-2 bg-white p-2 rounded-lg shadow-sm border">
                                        <span className="text-xs font-bold text-gray-400 uppercase px-2">Poziom:</span>
                                        {[1, 2, 3, 4, 5].map(lvl => (
                                            <button 
                                                key={lvl}
                                                onClick={() => setDifficultyFilter(difficultyFilter === lvl ? 'all' : lvl)}
                                                className={`w-8 h-8 rounded flex items-center justify-center text-sm font-bold transition ${difficultyFilter === lvl ? 'bg-indigo-600 text-white shadow' : 'text-gray-500 hover:bg-gray-100'}`}
                                            >
                                                {lvl}
                                            </button>
                                        ))}
                                        <button onClick={() => setDifficultyFilter('all')} className={`px-3 h-8 rounded text-sm font-bold transition ${difficultyFilter === 'all' ? 'bg-gray-800 text-white' : 'text-gray-500 hover:bg-gray-100'}`}>Wszystkie</button>
                                    </div>
                                </div>

                                <div className="flex-1 overflow-y-auto pr-2 pb-4">
                                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                                        {filteredTheorems.map(t => (
                                            <div key={t.id} onClick={() => startExercise(t)} className="group bg-white p-4 rounded-xl border border-gray-200 shadow-sm hover:shadow-md hover:border-indigo-400 cursor-pointer transition relative overflow-hidden">
                                                <div className={`absolute top-0 left-0 w-1 h-full ${
                                                    t.diff <= 1 ? 'bg-green-400' : t.diff <= 3 ? 'bg-yellow-400' : 'bg-red-500'
                                                }`}></div>
                                                <div className="pl-3">
                                                    <div className="flex justify-between items-start mb-2">
                                                        <span className="text-xs font-bold text-gray-400">#{t.id}</span>
                                                        <span className={`text-[10px] px-1.5 py-0.5 rounded font-bold uppercase tracking-wide ${
                                                            t.diff <= 1 ? 'bg-green-50 text-green-700' : t.diff <= 3 ? 'bg-yellow-50 text-yellow-700' : 'bg-red-50 text-red-700'
                                                        }`}>Lvl {t.diff}</span>
                                                    </div>
                                                    <div className="font-mono text-sm font-semibold text-gray-900 mb-2 break-words group-hover:text-indigo-700 transition-colors">{t.formula}</div>
                                                    <div className="text-xs text-gray-500 leading-tight">{t.name}</div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        )}

                        {view === 'solve' && selectedExercise && (
                            <div className="fade-in h-full flex flex-col">
                                <div className="mb-4 flex items-center gap-4 bg-white p-3 rounded shadow-sm border flex-shrink-0">
                                    <button onClick={() => setView('practice')} className="text-indigo-600 hover:bg-indigo-50 px-3 py-1 rounded transition flex items-center gap-2 font-bold text-sm">
                                        <span>←</span> Powrót
                                    </button>
                                    <div className="h-8 w-px bg-gray-200"></div>
                                    <div>
                                        <h2 className="font-bold text-gray-800 text-lg">{selectedExercise.name}</h2>
                                        <div className="text-xs text-gray-500">Twierdzenie #{selectedExercise.id}</div>
                                    </div>
                                </div>
                                <div className="flex-1 overflow-hidden">
                                    <ProofEditor initialGoal={selectedExercise.formula} exerciseId={selectedExercise.id} />
                                </div>
                            </div>
                        )}
                    </main>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>